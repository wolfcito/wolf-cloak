import type { IJubPoint } from "../../types";
import { toHex } from "../../utils/conversion";
import { CurvePoint } from "../ecc/CurvePoint";

interface DecryptionProps {
	decrypted: IJubPoint;
	handleDecrypt: () => void;
	canDecrypt: boolean;
	packedOriginal: string;
	packedDecrypted: string;
}

export const Decryption = ({
	decrypted,
	handleDecrypt,
	canDecrypt,
	packedOriginal,
	packedDecrypted,
}: DecryptionProps) => {
	return (
		<div className="font-mono">
			<div className="border border-red-500/40 p-4 rounded bg-black/20">
				<h3 className="font-bold mb-2">üîë Strategy</h3>
				<p>
					Using the private key <code>x</code>, recover the original message
					point by reversing the encryption process with{" "}
					<code>M = C‚ÇÇ - xC‚ÇÅ</code>. Here, <code>xC‚ÇÅ</code> reconstructs the
					shared secret used during encryption, and subtracting it from{" "}
					<code>C‚ÇÇ</code> reveals the original message point <code>M</code> on
					the BabyJubjub curve.
				</p>
			</div>
			<button
				onClick={handleDecrypt}
				type="button"
				disabled={!canDecrypt}
				className="bg-cloak-dark w-full text-discord-accent px-2 py-1 rounded-md text-sm border border-red-500/60 mt-4 disabled:opacity-50 disabled:cursor-not-allowed mb-2 hover:bg-red-500/60 transition-all duration-200"
			>
				Decrypt
			</button>
			{!!decrypted &&
				!!decrypted.x &&
				!!decrypted.y &&
				decrypted.x !== 0n &&
				decrypted.y !== 0n && (
					<>
						<p className="text-sm font-mono text-cloak-gray my-2 italic">
							Note: After decrypting an ElGamal ciphertext, the result is a
							point on the BabyJubjub curve. Retrieving the original numeric
							message (scalar) from this point would normally require complex
							algorithms like Baby-Step Giant-Step (BSGS), which aren't
							practical to run in a browser. Instead, to verify correctness
							quickly, we compare the decrypted point directly with the original
							point generated by multiplying the scalar message with the curve's
							base point (Base8).
						</p>

						<CurvePoint
							x={decrypted.x}
							y={decrypted.y}
							onChange={() => {}}
							shouldCollapse={false}
							label="Decrypted Point"
						/>

						<div
							className={`text-xs p-3 rounded-md font-mono mt-2 ${
								packedOriginal === packedDecrypted
									? "bg-red-500/5 border border-red-500/40 text-discord-accent"
									: "bg-cloak-red/5 border border-cloak-red/40 text-cloak-red"
							}`}
						>
							<p className="mb-2 font-semibold">
								{packedOriginal === packedDecrypted
									? "‚úÖ Points match"
									: "‚ùå Points do not match"}
							</p>
							<p>
								Original message (mG): <code>{toHex(packedOriginal)}</code>
							</p>
							<p>
								Decrypted message (M): <code>{toHex(packedDecrypted)}</code>
							</p>
						</div>
					</>
				)}
		</div>
	);
};
