// Modified from: https://github.com/iden3/circomlibjs/blob/main/src/poseidon_reference.js
import { poseidonConstants } from "./constants";

class FieldObject {
	prime: bigint;
	zero: bigint;

	constructor(prime: string) {
		this.prime = BigInt(prime);
		this.zero = BigInt(0);
	}

	modPrimeBigInt(elem: bigint): bigint {
		let ret = elem % this.prime;
		if (ret < 0) {
			ret = ret + this.prime;
		}
		return ret;
	}

	mapStringToFieldElem(elem: string): bigint {
		if (elem.startsWith("0x"))
			return this.modPrimeBigInt(BigInt(`0x${elem.slice(2)}`));

		return this.modPrimeBigInt(BigInt(elem));
	}

	mapBigIntNativeToField(elem: bigint): bigint {
		return this.modPrimeBigInt(elem);
	}

	add(elem1: bigint, elem2: bigint): bigint {
		return this.modPrimeBigInt(elem1 + elem2);
	}

	mul(elem1: bigint, elem2: bigint): bigint {
		return this.modPrimeBigInt(elem1 * elem2);
	}

	exp(elem: bigint, power: number): bigint {
		return this.modPrimeBigInt(elem ** BigInt(power));
	}
}

//@ts-ignore
function unsringifyConstants(F: FieldObject, o) {
	if (typeof o === "string" && /^[0-9]+$/.test(o)) {
		return F.mapStringToFieldElem(o);
	}
	if (typeof o === "string" && /^0x[0-9a-fA-F]+$/.test(o)) {
		return F.mapStringToFieldElem(o);
	}
	if (Array.isArray(o)) {
		return o.map(unsringifyConstants.bind(null, F));
	}
	if (typeof o === "object") {
		if (o === null) return null;
		const res = {};
		const keys = Object.keys(o);
		for (const k of keys) {
			//@ts-ignore
			res[k] = unsringifyConstants(F, o[k]);
		}
		return res;
	}
	return o;
}

function buildPoseidon(prime: string) {
	const F: FieldObject = new FieldObject(prime);

	// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
	// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
	const { C, M } = unsringifyConstants(F, poseidonConstants);

	// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
	// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
	// And rounded up to nearest integer that divides by t
	const N_ROUNDS_F = 8;
	const N_ROUNDS_P = [
		56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68,
	];

	const pow5 = (a: bigint) => F.exp(a, 5);

	function poseidon(inputs: bigint[]) {
		if (inputs.length <= 0) return 0n;

		const t = inputs.length + 1;
		const nRoundsF = N_ROUNDS_F;
		const nRoundsP = N_ROUNDS_P[t - 2];

		const initState = F.zero;
		const nOut = 1;

		let state = [
			initState,
			...inputs.map((a: bigint) => F.mapBigIntNativeToField(a)),
		];
		for (let r = 0; r < nRoundsF + nRoundsP; r++) {
			state = state.map((a, i) => F.add(a, C[t - 2][r * t + i]));

			if (r < nRoundsF / 2 || r >= nRoundsF / 2 + nRoundsP) {
				state = state.map((a) => pow5(a));
			} else {
				state[0] = pow5(state[0]);
			}

			state = state.map((_, i) =>
				state.reduce(
					(acc, a, j) => F.add(acc, F.mul(M[t - 2][i][j], a)),
					F.zero,
				),
			);
		}
		return state.slice(0, nOut);
	}

	poseidon.F = F;
	return poseidon;
}

export function poseidon(inputs: bigint[], prime: string): bigint[] {
	if (inputs.length <= 0 || inputs.length > 16) return [];
	const _poseidonFunction = buildPoseidon(prime);
	const x = _poseidonFunction(inputs) as bigint[];
	return x;
}
